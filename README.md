# Синхронный и асинхронный в JavaScript

JavaScript известен своей способностью обрабатывать как **синхронные** , так и **асинхронные** операции. Понимание того, как работают эти две вещи, важно для написания эффективных, отзывчивых и удобных для пользователя приложений. В этой статье мы увидим различия между синхронным и асинхронным JavaScript с наглядными примерами, которые помогут вам.

![image](https://github.com/user-attachments/assets/2a0695aa-6d3a-49f1-9a40-548f8dff9a86)

Что такое синхронный JavaScript?
В синхронном программировании операции выполняются одна за другой, в определенной последовательности. Таким образом, в основном каждая строка кода ожидает завершения предыдущей, прежде чем перейти к следующей. Это означает, что программа выполняется в предсказуемом линейном порядке, при этом каждая задача завершается до запуска следующей.

Пример: В этом примере мы показали синхронную природу JavaScript.

```java
console.log("Hi");
console.log("Geek");
console.log("How are you?");
```
Вывод
```
Hi
Geek
How are you?
```
В приведенном выше фрагменте кода первая строка кода Hi будет регистрироваться первой, затем будет регистрироваться вторая строка Geek , а затем, после ее завершения, будет регистрироваться третья строка Как дела. Итак, как мы можем видеть, коды работают последовательно. Каждая строка кода ожидает выполнения предыдущей, а затем выполняется сама.

В синхронном коде каждый оператор ожидает завершения предыдущего перед его запуском. Это простой и понятный способ, но у него есть некоторые недостатки, особенно при решении таких трудоемких задач, как извлечение данных с сервера или чтение большого файла. Если такая задача включена в последовательность, она заблокирует выполнение остальной части кода до его завершения, что приведет к потенциальным задержкам и плохому взаимодействию с пользователем.

# Что такое асинхронный JavaScript?

**Асинхронное** программирование, с другой стороны, позволяет нескольким задачам выполняться независимо друг от друга. В асинхронном коде задача может быть инициирована, и в ожидании ее завершения могут выполняться другие задачи. Такая неблокирующая природа помогает повысить производительность и оперативность реагирования, особенно в веб-приложениях.

Пример: В этом примере мы показали асинхронную природу JavaScript.

```java
console.log("Hi");

setTimeout(() => {
    console.log("Geek");
}, 2000);

console.log("End");
```
Вывод
```java
Hi
End
Geek
```
Итак, что делает код, так это сначала он входит в систему Hi затем вместо выполнения функции **setTimeout** он входит в систему **End** и затем запускает функцию **setTimeout** .

Сначала, как обычно, была зарегистрирована инструкция *Hi*. Поскольку мы используем браузеры для запуска *JavaScript*, существуют веб-API, которые обрабатывают эти вещи для пользователей. Итак, что делает **JavaScript**, так это передает функцию **setTimeout** в таком веб-API, а затем мы продолжаем выполнять наш код как обычно. Таким образом, он не блокирует выполнение остальной части кода, и после выполнения всего кода он попадает в стек вызовов и затем, наконец, выполняется. Это то, что происходит в асинхронном **JavaScript**.

# Как работает асинхронный *JavaScript* за кулисами

Чтобы лучше понять асинхронное поведение, важно знать о среде выполнения *JavaScript*, в частности о цикле событий и стеке вызовов:

+ Стек вызовов: Стек вызовов - это место, где функции выполняются в порядке их вызова. При синхронных операциях каждая функция добавляется в стек и выполняется перед переходом к следующей.
  
+ Веб-***API** (в браузерах): такие функции, как **setTimeout, HTTP**-запросы и прослушиватели событий, обрабатываются *веб-API* в браузере. Когда вызывается асинхронная функция, такая как **setTimeout**, она передается этим веб-**API**, которые управляют синхронизацией, не блокируя основной стек вызовов.
Очередь обратного вызова: как только ***веб-API*** завершает свою работу (например, ожидает истечения тайм-аута), он помещает функцию обратного вызова (например, в *setTimeout* ) в очередь обратного вызова.
Цикл событий: Цикл событий непрерывно проверяет стек вызовов. Если он пуст, он помещает функции из очереди обратного вызова в стек для выполнения. Вот почему отложенное сообщение “Geek” регистри

#### Асинхронные обратные вызовы — это функции, передаваемые другой функции, которая начинает выполнение.код в фоновом режиме. Обычно, когда код в фоновом режиме завершается, асинхронныйФункция обратного вызова вызывается как способ уведомления и передачи данных обратному вызову.функция, подтверждающая завершение фоновой задачи.

```java
function get(callback) {
setTimeout(() => {
callback("Hello world!");
}, 2000);
get(function (value) {
console.log(value);
});
```

# В JavaScript обещание — 
это хороший способ обработки асинхронных операций. Этоиспользуется, чтобы узнать, успешно ли завершена асинхронная операция илинет.Конструктор ```Promise()``` принимает функцию в качестве аргумента. Функция также принимает две 
```resolve() и ignore()```.Если обещание возвращается успешно, вызывается ```resolve()```. И, если возникает ошибка, вызывается функция ```ignore()```.

```java script
let promise = new Promise((resolve, reject) =
// do something
});
```

#### Ключевое слово async преобразует обычную функцию 
```JavaScript``` васинхронная функция, заставляющая ее возвращать обещание. Ключевое слово ожидания:используется внутри асинхронной функции, чтобы приостановить ее выполнение и дождаться выполнения обещания.решите, прежде чем продолжить.

```js
async function name(parameter1, parameter2, parametern)
{
 // statements
}
```

```js
function fetchData() {
return new Promise((resolve, reject)
(
setTimeout(()
resolve("Данные успешно загружены!");
), 2000);
3);
async function loadData() {
try {
console.log("Начало загрузки данных…");
Ждем, пока данные будут загружены
const data = await fetchData();
console.log("Данные:", data);
catch (error) { console.error("Ошибка загрузки данных:", error);
Выловем пеннхронну функцию для загрузки данных
loadData();
```

# try/catch

+ Конструкция ```try...catch``` пытается выполнить инструкции в ```try```.блок, и в случае возникновения ошибки выполняет блок ```catch```.

```js
async function fetchData() try {
const response = await fetch(' https://example.com/data '); const data = await response.json();
return data;
}catch (error) {
console. error(error);
throw пеw Error("Ошибка при получении данных");
fetchData()
then((data)= console.log(data))
.catch((error)=console.error(error));
```

+ ```try...catch``` работает следующим образом: код, который может выдать ошибка помещается в блок ```try```. Если возникает ошибка в блок ```try```, программа переходит к блоку ```catch```, где вы можете обработать ошибку принять необходимые действия. Однако остальная часть кода продолжает выполните, и ваше приложение не сломается.

+ Вы можете использовать асинхронный функции и ожидание оператор в блоке ```try``` для выполнять операции, которые могут вызывать ошибки. Если возникает ошибка в блоке ```try```, затем программа переходит в блок ```catch```, где вы можете обработать ошибку и выполнить необходимые действия

```js
function fetchData()
return new Promise((resolve, reject) {setTimeout(() = const randomNumber = Math.random();
 if (randomNumber < 0.5) {
resolve("Данные успешно загружены!");
else { reject("Ошибка загрузки данных!");
}})}, 2000);
async function loadData()
try (
console.log("Начало загрузки данных…");
// Ждем, пока знные будут загружены
const data = await fetchData(); console.log("Данные: ", data)); }
catch (error) {
console.error("Ошибка загрузки данных:",error);
loadData() ;
}
```
