
# Синхронный и асинхронный в JavaScript

JavaScript известен своей способностью обрабатывать как **синхронные** , так и **асинхронные** операции. Понимание того, как работают эти две вещи, важно для написания эффективных, отзывчивых и удобных для пользователя приложений. В этой статье мы увидим различия между синхронным и асинхронным JavaScript с наглядными примерами, которые помогут вам.

![image](https://github.com/user-attachments/assets/2a0695aa-6d3a-49f1-9a40-548f8dff9a86)

Что такое синхронный JavaScript?
В синхронном программировании операции выполняются одна за другой, в определенной последовательности. Таким образом, в основном каждая строка кода ожидает завершения предыдущей, прежде чем перейти к следующей. Это означает, что программа выполняется в предсказуемом линейном порядке, при этом каждая задача завершается до запуска следующей.

Пример: В этом примере мы показали синхронную природу JavaScript.

```java
console.log("Hi");
console.log("Geek");
console.log("How are you?");
```
Вывод
```
Hi
Geek
How are you?
```
В приведенном выше фрагменте кода первая строка кода Hi будет регистрироваться первой, затем будет регистрироваться вторая строка Geek , а затем, после ее завершения, будет регистрироваться третья строка Как дела. Итак, как мы можем видеть, коды работают последовательно. Каждая строка кода ожидает выполнения предыдущей, а затем выполняется сама.

В синхронном коде каждый оператор ожидает завершения предыдущего перед его запуском. Это простой и понятный способ, но у него есть некоторые недостатки, особенно при решении таких трудоемких задач, как извлечение данных с сервера или чтение большого файла. Если такая задача включена в последовательность, она заблокирует выполнение остальной части кода до его завершения, что приведет к потенциальным задержкам и плохому взаимодействию с пользователем.

# Что такое асинхронный JavaScript?

**Асинхронное** программирование, с другой стороны, позволяет нескольким задачам выполняться независимо друг от друга. В асинхронном коде задача может быть инициирована, и в ожидании ее завершения могут выполняться другие задачи. Такая неблокирующая природа помогает повысить производительность и оперативность реагирования, особенно в веб-приложениях.

Пример: В этом примере мы показали асинхронную природу JavaScript.

```java
console.log("Hi");

setTimeout(() => {
    console.log("Geek");
}, 2000);

console.log("End");
```
Вывод
```java
Hi
End
Geek
```
Итак, что делает код, так это сначала он входит в систему Hi затем вместо выполнения функции **setTimeout** он входит в систему **End** и затем запускает функцию **setTimeout** .

Сначала, как обычно, была зарегистрирована инструкция *Hi*. Поскольку мы используем браузеры для запуска *JavaScript*, существуют веб-API, которые обрабатывают эти вещи для пользователей. Итак, что делает **JavaScript**, так это передает функцию **setTimeout** в таком веб-API, а затем мы продолжаем выполнять наш код как обычно. Таким образом, он не блокирует выполнение остальной части кода, и после выполнения всего кода он попадает в стек вызовов и затем, наконец, выполняется. Это то, что происходит в асинхронном **JavaScript**.

# Как работает асинхронный *JavaScript* за кулисами

Чтобы лучше понять асинхронное поведение, важно знать о среде выполнения *JavaScript*, в частности о цикле событий и стеке вызовов:

+ Стек вызовов: Стек вызовов - это место, где функции выполняются в порядке их вызова. При синхронных операциях каждая функция добавляется в стек и выполняется перед переходом к следующей.
  
+ Веб-***API** (в браузерах): такие функции, как **setTimeout, HTTP**-запросы и прослушиватели событий, обрабатываются *веб-API* в браузере. Когда вызывается асинхронная функция, такая как **setTimeout**, она передается этим веб-**API**, которые управляют синхронизацией, не блокируя основной стек вызовов.
Очередь обратного вызова: как только ***веб-API*** завершает свою работу (например, ожидает истечения тайм-аута), он помещает функцию обратного вызова (например, в *setTimeout* ) в очередь обратного вызова.
Цикл событий: Цикл событий непрерывно проверяет стек вызовов. Если он пуст, он помещает функции из очереди обратного вызова в стек для выполнения. Вот почему отложенное сообщение “Geek” регистри
